import 'dart:io';
import 'dart:async';
import 'package:args/args.dart';
import 'package:path/path.dart' as path;
import '../utils/logger.dart';
import '../utils/file_utils.dart';

class AssetsCommand {
  final Logger logger;

  AssetsCommand(this.logger);

  Future<void> execute(ArgResults results) async {
    final watch = results['watch'] as bool;

    if (watch) {
      logger.info('Starting asset watcher...');
      await _watchAssets();
    } else {
      await _generateAssets();
    }
  }

  Future<void> _generateAssets() async {
    logger.step('Generating asset constants...');

    final assetFiles = FileUtils.getAssetFileObjects();
    if (assetFiles.isEmpty) {
      logger.warning('No asset files found in common directories (assets, lib/assets, images, fonts)');
      return;
    }

    final assetsContent = _generateAssetsContent(assetFiles);
    final outputPath = 'lib/assets/app_assets.dart';

    FileUtils.writeFile(outputPath, assetsContent);
    logger.success('Generated ${assetFiles.length} asset constants in $outputPath');
  }

  Future<void> _watchAssets() async {
    final assetDirs = ['assets', 'lib/assets', 'images', 'fonts']
        .where((dir) => Directory(dir).existsSync())
        .toList();

    if (assetDirs.isEmpty) {
      logger.warning('No asset directories found to watch');
      return;
    }

    logger.info('Watching asset directories: ${assetDirs.join(', ')}');

    // Initial generation
    await _generateAssets();

    // Watch for changes
    final watchers = <StreamSubscription>[];

    for (final dirPath in assetDirs) {
      final dir = Directory(dirPath);
      final watcher = dir.watch(recursive: true);

      watchers.add(watcher.listen((event) async {
        if (event.type == FileSystemEvent.create ||
            event.type == FileSystemEvent.delete ||
            event.type == FileSystemEvent.modify) {
          logger.debug('Asset change detected: ${event.path}');
          await _generateAssets();
        }
      }));
    }

    logger.info('Asset watcher started. Press Ctrl+C to stop.');

    // Keep the process running
    await ProcessSignal.sigint.watch().first;

    // Clean up watchers
    for (final watcher in watchers) {
      await watcher.cancel();
    }

    logger.info('Asset watcher stopped.');
  }

  String _generateAssetsContent(List<File> assetFiles) {
    final buffer = StringBuffer();

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by QfTools on ${DateTime.now()}');
    buffer.writeln('');
    buffer.writeln('class AppAssets {');
    buffer.writeln('  AppAssets._();');
    buffer.writeln('');

    // Group assets by directory
    final assetsByDir = <String, List<File>>{};

    for (final file in assetFiles) {
      final dir = path.dirname(FileUtils.getRelativePath(file.path));
      assetsByDir.putIfAbsent(dir, () => []).add(file);
    }

    // Generate constants for each directory
    for (final entry in assetsByDir.entries) {
      final dirName = entry.key.replaceAll('/', '').replaceAll('\\', '');
      if (dirName.isNotEmpty) {
        buffer.writeln('  // ${entry.key}');
      }

      for (final file in entry.value) {
        final constantName = FileUtils.filePathToConstantName(file.path);
        final assetPath = FileUtils.filePathToAssetPath(file.path);

        if (constantName.isNotEmpty) {
          buffer.writeln('  static const String $constantName = \'$assetPath\';');
        }
      }

      buffer.writeln('');
    }

    buffer.writeln('}');

    return buffer.toString();
  }
}
